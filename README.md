<p align="center">
  <a href="" rel="noopener">
 <img src="http://optimizer.math.sharif.edu/wp-content/uploads/2021/02/optimizer.png" alt="Optimizer logo"></a>
</p>
<h3 align="center">عقاب‌های خسته‌بال</h3>

---

<div dir = "rtl">
<p align="center"> در این بخش هدف پیدا کردن ماتریس
  V
  ای بود که درایه‌های آن در بازه‌های داده‌شده قرار داشته باشند. همچنین می‌خواستیم 
  V
  را به‌گونه‌ای پیدا کنیم که تا جای ممکن بیشترین تعداد سطر تمام صفر را داشته باشد و علاوه بر این، برای ماتریس S داده‌شده، SV بیشترین تعداد ستون ۰ ممکن را داشته باشد.
  این مساله یک مساله است که در آن چند تابع هدف داریم. به همین دلیل مقدار λ به ما داده شده بود و هدف این بود که λ برابر تابع هدف دوم به اضافه تابع هدف اول را کمینه کنیم.  
  بعد از بررسی سه ورودی داده‌شده در این سوال، متوجه شدیم که در هرسه‌ی این ورودی‌ها، جواب بهینه به ازای حالتی به‌دست می‌اید که تمام ستون‌های SV برابر ۰ باشند. به این صورت مساله به همان مساله‌ی دور سوم تبدیل می‌شود. اما از آنجا که ابعاد ورودی‌های این دور بزرگ بود، برای حل مساله دور سوم در این دور از مسابقه از ایده‌ی دیگری استفاده کردیم. این ایده را در قسمت ایده‌های گسترش دور سوم توضیح داده‌ایم. ایده این است که ابتدا به ستون‌های V به صورت بردارهای مجزا از هم نگاه کنیم و با استفاده از روش دور دوم، به ازای هر ستون از V مقادیری پیدا کنیم که هم در بازه‌های داده‌شده برای درایه‌های آن صدق کند، هم Sv برابر با ۰ باشد (در اینجا v ستون مورد نظر از V در نظر گرفته شده است) و همچنین v تعداد زیادی درایه ۰ داشته باشد.  
 با کنار هم قرار دادن ستون‌های به‌دست آمده، یک ماتریس V اولیه به‌دست می‌آوریم که در شرایط مساله صدق کرده و به ازای آن همه ستون‌های SV برابر ۰ به‌دست می‌آیند. با این کار، تعدادی از سطرهای V خودبه‌خود ۰ می‌شوند. همچنین تعدادی از سطرهای V هستند که امکان ندارد ۰ شوند چرا که یکی از عناصر آن سطر باید در بازه‌ای باشد که شامل ۰ نیست. اگر این سطرها را از V حذف کنیم، تعداد کمی سطر باقی می‌ماند که این سطرها ۰ نیستند ولی قابلیت ۰ شدن را دارند. در نهایت با استفاده از MILP تعدادی از این سطرها را ۰ می‌کنیم به طوری که V حاصل همچنان در شروط مساله صدق بکند و SV نیز همچنان برابر ۰ باشد. به این صورت جواب را بهبود می‌بخشیم. 
    <br> 
</p>
 </div>

## 📝 فهرست مطالب
- [صورت‌بندی سوال](#problem_statement)
- [الگوریتم بهینه‌سازی](#idea)
- [محدودیت‌ها](#limitations)
- [ایده‌های گسترش](#future_scope)
- [روند اجرا](#getting_started)
<!--- - [نحوه استفاده](#usage) --->
- [وابستگی‌ها](#tech_stack)
- [نویسندگان](#authors)
<!--- - [قدردانی](#acknowledgments) --->

## 🧐 صورت‌بندی سوال <a name = "problem_statement"></a>
![main_problem](https://github.com/AhmadRHM/Optimizer2021_Round4/blob/main/images/main_problem.png)

## 💡 الگوریتم بهینه‌سازی <a name = "idea"></a>
<div dir = "rtl">
 همانطور که در بالاتر نیز گفته شد، ابتدا با استفاده از روش گام به گام در دور دوم، ستون‌های V را به طور مستقل به شکلی پر می‌کنیم که در نهایت V در شرایط مساله صدق کرده و SV = 0 شود. سپس سطرهایی از V حاصل که ۰ شده‌اند را از آن حذف می‌کنیم و ستون‌های متناظر با این سطرها را نیز از S حذف می‌کنیم. در نهایت، با استفاده از MILP زیر تعداد بیشتری از سطرهای V را ۰ می‌کنیم تا به جواب بهتری برسیم  
  
![l0_problem](https://github.com/AhmadRHM/Optimizer2021_Round4/blob/main/images/MILP_problem.png)    
</div>

## ⛓️ محدودیت‌ها <a name = "limitations"></a>
  <div dir = "rtl">
  طبیعتا این راه حل در شرایطی به پاسخ خوبی دست پیدا می‌کند که جواب بهینه در حالتی رخ دهد که در آن SV=0. با توجه به این که ساختن V اولیه حل کردن تعدادی LP نسبتا کوچک است این بخش نسبتا سریع انجام می‌شود. همچنین با حذف سطرهای تمام ۰ از V حاصل، مساله به مقدار خوبی کوچک می‌شود و به همین دلیل MILP حاصل نیز به سرعت حل می‌شود. 
  </div>
  
## 🚀 ایده‌های گسترش <a name = "future_scope"></a>
<div dir = "rtl">
با توجه به این که در این دور از مسابقه، ورودی‌ها به ازای حالت SV=0 به جواب بهینه می‌رسیدند، ما از همین روشی که در بالا توضیح داده شد استفاده کردیم. اما برای حالتی که جواب بهینه در SV=0 صدق نکند، روش بالا لزوما جواب خوبی نمی‌دهد. یک ایده برای حل سوال در چنین شرایطی این است که بعد از به‌دست آوردن ماتریس V اولیه، ابتدا با استفاده از MILP تعدادی از ستون‌های V را تمام ۰ کنیم (طبعا فقط آن درایه‌هایی که می‌توانند ۰ شوند را ۰ می‌کنیم) و بعد از انجام این کار با استفاده از MILP تعدادی از سطرها را ۰ می‌کنیم. روشی مشابه این روش در دور پنجم پیاده‌سازی شده است. برای توضیحات بیشتر و کد به دور پنجم مراحعه کنید. 
</div>

## 🏁 روند اجرا <a name = "getting_started"></a>
<div dir = "rtl">
کافیست کد را در کنار فایل ورودی قرار داده، نام فایل ورودی را در کد در خط دوم سلول دوم به نام فایل ورودی مورد نظر تغییر داده؛ مقادیر size_of_v_r, size_of_v_c  را نیز که سایز ماتریس V خروجی است و , size_of_s_r را که تعداد سطرهای ماتریس S است، در خطوط اول تا سوم از سلول سوم، با توجه به ابعاد داده‌ی ورودی به‌روزرسانی کنید. در نهایت سلول‌ها را به ترتیب اجرا کنید. پس از اتمام اجرا، خروجی مورد نظر در فایل output.txt در کنار کد ذخیره خواهد شد.
بالای بعضی سلول‌ها نیز توضیحی داده شده که در آن سلول چه اتفاقی دارد می‌افتد.
</div>

### پیش‌نیازها
<div dir = "rtl">
  از آنجا که در کد از زبان جولیا استفاده شده‌است، نیاز است این زبان نصب شود. همچنین بسته‌هایی که در سلول اول کد استفاده شده‌اند نیز باید نصب شود. برای نصب جولیا و بسته‌های مورد نظر می‌توانید به وب‌سایت جولیا مراجعه کنید.
  </div>

### نصب

## ⛏️ وابستگی‌ها <a name = "tech_stack"></a>
<div dir = "rtl">
همانطور که در بخش پیشنیازها گفته شد، باید زبان Julia نصب شود.
  همچنین پکیج‌های زیر نیز باید در Julia نصب شوند:
</div>
  
  
* JuMP
* Cbc
* ECOS
* GLPK
* MAT
* SparseArrays
* DelimitedFiles 
* LinearAlgebra
* MathOptInterface

## ✍️ نویسندگان <a name = "authors"></a>
<div dir = "rtl">
 احمد رحیمی و دیبا هاشمی
</div>
<!---## 🎉 قدردانی <a name = "acknowledgments"></a>
تشکر از هر کسی که به نحوی در گسترش این کد به شما کمک کرده است
--->
